!pip install -q openpyxl pdfplumber matplotlib pandas numpy

import os, re, warnings, logging, difflib
from datetime import datetime
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from google.colab import files as gfiles
import pdfplumber

warnings.filterwarnings("ignore")
logging.basicConfig(level=logging.INFO,
                    format="%(asctime)s %(levelname)s %(message)s")
logger = logging.getLogger("financial_risk_qa")

company = input("Enter the name of the company: ").strip()
print(f"You entered: {company}\nNow upload financial reports (Excel/PDF).")

KEY_INCOME = ["profit", "net income", "net profit", "earnings"]
KEY_BAL = ["total assets", "equity", "deposits", "loans"]
KEY_CASH = ["cash and cash equivalents", "cash"]

CUR_SYMS = {"$": "USD", "₹": "INR", "€": "EUR", "£": "GBP", "rm": "MYR"}

SYNONYMS = {
    "profit": ["net income", "net profit", "profit after tax", "earnings",
               "profit/(loss)", "pat", "net earnings",
               "profit attributable", "income attributable"],
    "total assets": ["total assets", "assets total", "assets",
                     "total consolidated assets",
                     "consolidated total assets", "total asset",
                     "total capital and liabilities"],
    "equity": ["equity", "shareholders' equity", "shareholders equity",
               "total equity", "stockholders' equity", "stockholders equity",
               "net worth", "total shareholders equity", "common equity",
               "total stockholders equity", "reserves and surplus",
               "reserves & surplus", "capital and reserves"],
    "deposits": ["deposits", "total deposits", "customer deposits",
                 "deposit liabilities", "total deposit liabilities",
                 "total customer deposits", "deposit balances",
                 "public deposits"],
    "loans": ["loans", "gross loans", "total loans", "advances",
              "loan book", "loans and leases", "net loans",
              "total gross loans", "loans outstanding",
              "total advances", "gross advances"],
    "cash and cash equivalents": [
        "cash and cash equivalents", "cash", "cash & equivalents",
        "cash & equiv.", "cash equivalents", "cash and due from banks",
        "cash due from", "cash balances",
        "cash and balances at central banks",
        "cash at bank and in hand", "total cash",
        "cash and balances with reserve bank"
    ]
}

def safe_div(a, b):
    if pd.isna(a) or pd.isna(b) or b == 0:
        return np.nan
    return a / b

def token_set(s):
    return " ".join(sorted(set(re.findall(r"[a-z0-9]+", str(s).lower()))))

def sim_ratio(a, b):
    return difflib.SequenceMatcher(None, token_set(a), token_set(b)).ratio()*100.0

def find_label_cells_fuzzy(df, key, max_rows=300, max_cols=80, thresh=75):
    keys = [key] + SYNONYMS.get(key, [])
    hits = []
    nrows = min(max_rows, df.shape[0])
    ncols = min(max_cols, df.shape[1])
    for i in range(nrows):
        for j in range(ncols):
            cell = str(df.iat[i, j]).strip().lower()
            if not cell or len(cell) < 3:
                continue
            scores = [(cand, sim_ratio(cell, cand)) for cand in keys]
            if not scores:
                continue
            best = max(scores, key=lambda x: x[1])
            if best[1] >= thresh:
                hits.append((i, j, cell, best[0], best[1]))
    return hits

def extract_numeric_neighbor(df, row, col):
    cand = (
        [(row, col+o) for o in range(1, 8) if col+o < df.shape[1]] +
        [(row, col-o) for o in range(1, 6) if col-o >= 0] +
        [(row+o, col) for o in range(0, 8) if row+o < df.shape[0]]
    )
    for (r, c) in cand:
        v = df.iat[r, c]
        st = re.sub(r"[^\d\-\.\,()]", "", str(v)).replace(",", "")
        st = st.replace("(", "-").replace(")", "")
        if st.strip() == "":
            continue
        if re.match(r"^\-?\d+(\.\d+)?$", st):
            return float(st)
        m = re.search(r"\-?\d[\d\.]*", st)
        if m:
            try:
                return float(m.group(0))
            except:
                pass
    return np.nan

def search_and_extract_fuzzy(df, key):
    hits = find_label_cells_fuzzy(df, key)
    if not hits:
        return np.nan
    for (r, c, _, _, _) in sorted(hits, key=lambda x: x[0]):
        v = extract_numeric_neighbor(df, r, c)
        if not (isinstance(v, float) and np.isnan(v)):
            return v
    return np.nan

def detect_scale_and_ccy(text):
    t = text.lower()
    scale = 1.0
    if any(x in t for x in ["in crores", "in crore", "₹ crore"]):
        scale = 1e7
    elif any(x in t for x in ["in lakhs", "in lakh", "₹ lakh"]):
        scale = 1e5
    elif any(x in t for x in ["in millions", "in million", "(millions)",
                              "amounts in millions"]):
        scale = 1e6
    elif any(x in t for x in ["in thousands", "in '000", "in 000s",
                              "rm'000", "(thousands)",
                              "amounts in thousands"]):
        scale = 1e3
    ccy = None
    for sym, name in CUR_SYMS.items():
        if sym in text or name.lower() in t:
            ccy = name
            break
    return scale, ccy

def sheet_score(text, keys):
    s = text.lower()
    return sum(2 for k in keys if k in s) + (1 if re.search(r"\d{3,}", s) else 0)

def find_best_sheets(path):
    xl = pd.ExcelFile(path)
    scored = []
    for sh in xl.sheet_names:
        try:
            df = pd.read_excel(path, sheet_name=sh, header=None,
                               nrows=120, dtype=str)
            combined = " ".join(
                df.fillna("").astype(str).values.flatten()
            ).lower()
        except:
            combined = ""
        scored.append(
            (sh,
             sheet_score(combined, KEY_INCOME),
             sheet_score(combined, KEY_BAL),
             sheet_score(combined, KEY_CASH),
             combined)
        )
    return (
        max(scored, key=lambda x: x[1])[0],
        max(scored, key=lambda x: x[2])[0],
        max(scored, key=lambda x: x[3])[0],
        " ".join(s[4] for s in scored)
    )

def parse_quarter_from_filename(fname):
    s = fname.lower()
    m = re.search(r"q[^\d]*([1-4])[^0-9]*([0-9]{2,4})", s)
    if not m:
        m = re.search(r"([1-4])q[^\d]*([0-9]{2,4})", s)
    if m:
        q = int(m.group(1))
        yy = m.group(2)
        year = int(yy) if len(yy) == 4 else 2000 + int(yy)
        month = {1: 3, 2: 6, 3: 9, 4: 12}[q]
        return datetime(year, month, 1)
    m2 = re.search(r"(20[0-9]{2})", s)
    if m2:
        return datetime(int(m2.group(1)), 1, 1)
    return None

def extract_from_excel(excel_file):
    income_sh, balance_sh, cash_sh, combined_text = find_best_sheets(excel_file)
    scale, ccy = detect_scale_and_ccy(combined_text)
    try:
        df_inc = pd.read_excel(excel_file, sheet_name=income_sh,
                               header=None, nrows=600, dtype=str)
    except:
        df_inc = pd.DataFrame()
    try:
        df_bal = pd.read_excel(excel_file, sheet_name=balance_sh,
                               header=None, nrows=600, dtype=str)
    except:
        df_bal = pd.DataFrame()
    try:
        df_cash = pd.read_excel(excel_file, sheet_name=cash_sh,
                                header=None, nrows=600, dtype=str)
    except:
        df_cash = pd.DataFrame()

    raw_profit = search_and_extract_fuzzy(df_inc, "profit")
    raw_assets = search_and_extract_fuzzy(df_bal, "total assets")
    raw_equity = search_and_extract_fuzzy(df_bal, "equity")
    raw_deposits = search_and_extract_fuzzy(df_bal, "deposits")
    raw_loans = search_and_extract_fuzzy(df_bal, "loans")
    raw_cash = search_and_extract_fuzzy(df_cash, "cash and cash equivalents")

    rec = {
        "source_file": excel_file,
        "scale_factor": scale,
        "currency": ccy,
        "company": company
    }
    rec["profit"] = raw_profit * scale if not np.isnan(raw_profit) else np.nan
    rec["total_assets"] = raw_assets * scale if not np.isnan(raw_assets) else np.nan
    rec["equity"] = raw_equity * scale if not np.isnan(raw_equity) else np.nan
    rec["deposits"] = raw_deposits * scale if not np.isnan(raw_deposits) else np.nan
    rec["loans"] = raw_loans * scale if not np.isnan(raw_loans) else np.nan
    rec["cash"] = raw_cash * scale if not np.isnan(raw_cash) else np.nan
    rec["report_date"] = parse_quarter_from_filename(excel_file)
    return rec

def extract_numeric_value(text):
    text = str(text).replace(",", "").strip()
    numbers = re.findall(r"[\d]+", text)
    if numbers:
        try:
            return float(numbers[0])
        except:
            pass
    return np.nan

def find_value_in_pdf_tables(tables, keywords):
    for table in tables:
        for row in table:
            row_text = " ".join([str(cell).lower() for cell in row])
            if any(kw.lower() in row_text for kw in keywords):
                for cell in row:
                    val = extract_numeric_value(cell)
                    if not np.isnan(val) and val > 100000:
                        return val
    return np.nan

def extract_tables_from_pdf(pdf_path):
    all_tables = []
    with pdfplumber.open(pdf_path) as pdf:
        for page_idx, page in enumerate(pdf.pages):
            tables = page.extract_tables()
            if tables:
                for table in tables:
                    if table and len(table) > 1:
                        all_tables.append(table)
    return all_tables

def extract_from_pdf(pdf_file):
    tables = extract_tables_from_pdf(pdf_file)
    profit = find_value_in_pdf_tables(tables,
                ["profit", "net income", "net profit", "pat"])
    total_assets = find_value_in_pdf_tables(tables,
                ["total assets", "total capital"])
    equity = find_value_in_pdf_tables(tables,
                ["equity", "reserves", "capital"])
    deposits = find_value_in_pdf_tables(tables,
                ["deposits", "customer deposits"])
    loans = find_value_in_pdf_tables(tables,
                ["loans", "advances", "gross advances"])
    cash = find_value_in_pdf_tables(tables,
                ["cash", "balances with rbi"])
    m = re.search(r"202[0-9]", pdf_file)
    report_date = datetime.strptime(m.group(0), "%Y") if m else datetime.now()
    rec = {
        "source_file": pdf_file,
        "report_date": report_date,
        "profit": profit,
        "total_assets": total_assets,
        "equity": equity,
        "deposits": deposits,
        "loans": loans,
        "cash": cash,
        "currency": "INR" if any(
            b in pdf_file.lower() for b in ["icici", "hdfc", "sbi"]
        ) else "USD",
        "scale_factor": 1e3,
        "company": company
    }
    return rec

logger.info("Upload files (Excel or PDF)")
uploaded = gfiles.upload()
excel_files = [fn for fn in uploaded.keys()
               if fn.lower().endswith((".xls", ".xlsx"))]
pdf_files = [fn for fn in uploaded.keys()
             if fn.lower().endswith(".pdf")]
if not excel_files and not pdf_files:
    raise SystemExit("No Excel or PDF files uploaded.")

records = []
for excel_file in sorted(excel_files):
    logger.info("Processing Excel: %s", excel_file)
    rec = extract_from_excel(excel_file)
    records.append(rec)

for pdf_file in sorted(pdf_files):
    logger.info("Processing PDF: %s", pdf_file)
    rec = extract_from_pdf(pdf_file)
    records.append(rec)

df = pd.DataFrame(records)
if "report_date" in df.columns:
    df = df.dropna(subset=["report_date"])
    df = df.sort_values("report_date").reset_index(drop=True)

df["ROA"] = df.apply(lambda r: safe_div(r.profit, r.total_assets), axis=1)
df["Debt"] = df["total_assets"] - df["equity"]
df["Debt_to_Equity"] = df.apply(lambda r: safe_div(r.Debt, r.equity), axis=1)
df["Loan_to_Deposit"] = df.apply(lambda r: safe_div(r.loans, r.deposits), axis=1)
df["Liquidity"] = df.apply(lambda r: safe_div(r.cash, r.deposits), axis=1)
df["Equity_Ratio"] = df.apply(lambda r: safe_div(r.equity, r.total_assets), axis=1)

df["risk_score"] = (
    0.7 * df["Debt_to_Equity"].rank(pct=True)
    + 0.3 * (1 - df["ROA"].rank(pct=True))
)
q75 = df["risk_score"].quantile(0.75)
q50 = df["risk_score"].quantile(0.50)
df["risk_level_used"] = np.where(
    df["risk_score"] >= q75, "High",
    np.where(df["risk_score"] >= q50, "Medium", "Low")
)

def pct(x):
    return f"{x*100:.1f}%" if pd.notna(x) else "NA"

def money_short(x):
    if pd.isna(x): return "NA"
    abx = abs(x)
    if abx >= 1e12: return f"{x/1e12:.2f}T"
    if abx >= 1e9:  return f"{x/1e9:.2f}B"
    if abx >= 1e6:  return f"{x/1e6:.2f}M"
    if abx >= 1e3:  return f"{x/1e3:.2f}K"
    return f"{x:.0f}"

latest = df.iloc[-1]
earliest = df.iloc[0]

summary_lines = [
    "=== FINANCIAL RISK ASSESSMENT REPORT ===",
    f"Institution: {company}",
    f"Period: {latest['report_date'].date()} | Currency: {latest.get('currency','NA')}",
    "",
    "Financial Performance:",
    f"  • Profit: {money_short(latest.get('profit'))}",
    f"  • Return on Assets (ROA): {pct(latest.get('ROA'))}",
    f"  • Total Assets: {money_short(latest.get('total_assets'))}",
    "",
    "Balance Sheet Health:",
    (
        f"  • Leverage (Debt-to-Equity): {latest.get('Debt_to_Equity'):.2f}x"
        if pd.notna(latest.get("Debt_to_Equity"))
        else "  • Leverage (Debt-to-Equity): NA"
    ),
    f"  • Liquidity (Cash/Deposits): {pct(latest.get('Liquidity'))}",
    f"  • Equity Ratio: {pct(latest.get('Equity_Ratio'))}",
    f"  • Loan-to-Deposit: {pct(latest.get('Loan_to_Deposit'))}",
    "",
    "Risk Assessment:",
    f"  • Risk Band: {latest.get('risk_level_used','NA')}",
    (
        f"  • Composite Risk Score: {latest.get('risk_score'):.3f}"
        if pd.notna(latest.get("risk_score"))
        else "  • Composite Risk Score: NA"
    ),
]
customer_summary = "\n".join(summary_lines)

plt.figure(figsize=(10, 4))
plt.plot(df["report_date"], df["profit"] / 1e9,
         marker="o", linewidth=2, color="#1f77b4")
plt.title(f"{company} - Profit Trend Over Time",
          fontsize=14, fontweight="bold")
plt.ylabel("Profit (Billions)", fontsize=11)
plt.xlabel("Quarter", fontsize=11)
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.savefig("/content/profit_trend.png", dpi=150)
plt.close()

if df["Debt_to_Equity"].notna().sum() > 0:
    plt.figure(figsize=(10, 4))
    plt.plot(df["report_date"], df["Debt_to_Equity"],
             marker="o", color="tomato", linewidth=2,
             label="Debt-to-Equity")
    plt.axhline(df["Debt_to_Equity"].quantile(0.75),
                color="gray", linestyle="--", linewidth=1.5,
                label="75th percentile")
    plt.legend(loc="best")
    plt.title(f"{company} - Leverage (Debt-to-Equity) Over Time",
              fontsize=14, fontweight="bold")
    plt.xlabel("Quarter", fontsize=11)
    plt.ylabel("Debt-to-Equity (x)", fontsize=11)
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.savefig("/content/debt_to_equity_trend.png", dpi=150)
    plt.close()

print("Rows:", len(df))
print(customer_summary)

!pip install -q perplexityai reportlab

from perplexity import Perplexity
from datetime import datetime
from reportlab.lib.pagesizes import letter
from reportlab.lib.units import inch
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet
from google.colab import files
import os

api_key = input("Enter your Perplexity API key: ").strip()
client = Perplexity(api_key=api_key)

context_text = f"""
TABULAR DATA (last 8 quarters):
{df.tail(8).to_string(index=False)}

SUMMARY:
{customer_summary}
"""

messages = [
    {
        "role": "system",
        "content": "You are a senior financial risk analyst.",
    },
    {
        "role": "user",
        "content": f"""
Write a detailed financial risk report with sections:
Executive Summary, Performance Analysis, Risk Assessment,
Strategic Recommendations, and Forward Outlook.

Use ONLY this data (do not invent new numbers):

{context_text}
""",
    },
]

completion = client.chat.completions.create(
    model="sonar-pro",
    messages=messages,
)
report_text = completion.choices[0].message.content

insights_path = "/content/ai_insights.txt"
with open(insights_path, "w", encoding="utf-8") as f:
    f.write(report_text)

pdf_path = "/content/Financial_Risk_Report.pdf"
styles = getSampleStyleSheet()
story = []

story.append(Paragraph("Financial Risk Assessment Report", styles["Title"]))
story.append(Spacer(1, 0.2 * inch))
story.append(Paragraph(f"Generated: {datetime.utcnow()} UTC", styles["Normal"]))
story.append(Spacer(1, 0.3 * inch))

for para in report_text.split("\n\n"):
    if para.strip():
        story.append(Paragraph(para.replace("\n", "<br/>"), styles["Normal"]))
        story.append(Spacer(1, 0.15 * inch))

for img_path in ["/content/profit_trend.png",
                 "/content/debt_to_equity_trend.png"]:
    if os.path.exists(img_path):
        story.append(Spacer(1, 0.3 * inch))
        story.append(Image(img_path, width=6*inch, height=3*inch))

doc = SimpleDocTemplate(pdf_path, pagesize=letter)
doc.build(story)

print("Saved TXT:", insights_path)
print("Saved PDF:", pdf_path)

files.download(pdf_path)
files.download(insights_path)


!pip install -q perplexityai

from perplexity import Perplexity

chat_api_key = input("Enter your Perplexity API key for chatbot: ").strip()
chat_client = Perplexity(api_key=chat_api_key)

def risk_chatbot(question: str) -> str:
    messages = [
        {
            "role": "system",
            "content": (
                "You are a financial risk tutor. "
                "Explain clearly and step by step using ONLY the data provided."
            ),
        },
        {
            "role": "user",
            "content": f"""
Here is the summary and latest metrics:

{customer_summary}

Latest metrics:
ROA: {pct(latest.get('ROA'))}
Debt-to-Equity: {latest.get('Debt_to_Equity')}
Loan-to-Deposit: {pct(latest.get('Loan_to_Deposit'))}
Liquidity (Cash/Deposits): {pct(latest.get('Liquidity'))}
Equity Ratio: {pct(latest.get('Equity_Ratio'))}
Risk Band: {latest.get('risk_level_used')}
Composite Risk Score: {latest.get('risk_score')}

User question: {question}

Answer ONLY about this bank, with no invented numbers.
""",
        },
    ]

    completion = chat_client.chat.completions.create(
        model="sonar-pro",
        messages=messages,
    )
    return completion.choices[0].message.content

print("Risk chatbot ready. Type questions, or 'exit' to stop.\n")

while True:
    q = input("You: ").strip()
    if q.lower() in ("exit", "quit"):
        print("Chat ended.")
        break
    if not q:
        continue
    ans = risk_chatbot(q)
    print("\nBot:", ans, "\n")



